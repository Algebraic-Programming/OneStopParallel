/*
Copyright 2024 Huawei Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

@author Toni Boehnlein, Benjamin Lozes, Pal Andras Papp, Raphael S. Steiner
*/

#pragma once

#include <vector>
#include <unordered_map>
#include "osp/dag_divider/isomorphism_divider/HashComputer.hpp"

namespace osp {

/**
 * @brief A class to store precomputed hash values for a set of objects and provide an orbit-based interface.
 *
 * This class takes a vector of hash values for objects indexed from 0 to n-1. It then computes the orbits
 * (i.e., groups of objects with the same hash value) and provides an interface identical to `MerkleHashComputer`.
 * This is useful when hashes are generated by external means but the orbit-based analysis is still desired.
 *
 * @tparam IndexType The type used for indexing the objects
 */
template<typename IndexType>
class PrecomputedHashComputer : public HashComputer<IndexType> {

    std::vector<std::size_t> vertex_hashes;
    std::unordered_map<std::size_t, std::vector<IndexType>> orbits;

  public:
    /**
     * @brief Construct a new Precomputed Hash Computer object.
     *
     * @param precomputed_hashes A vector of hash values for objects 0 to n-1.
     */
    PrecomputedHashComputer(const std::vector<std::size_t>& precomputed_hashes) : vertex_hashes(precomputed_hashes) {
        for (std::size_t i = 0; i < vertex_hashes.size(); ++i) {
            const auto& hash = vertex_hashes[i];
            orbits[hash].push_back(static_cast<IndexType>(i));
        }
    }

    virtual ~PrecomputedHashComputer() override = default;

    inline std::size_t get_vertex_hash(const IndexType &v) const override { return vertex_hashes[v]; }
    inline const std::vector<std::size_t> &get_vertex_hashes() const override { return vertex_hashes; }
    inline std::size_t num_orbits() const override { return orbits.size(); }
    
    inline const std::vector<IndexType> &get_orbit(const IndexType &v) const override { return this->get_orbit_from_hash(this->get_vertex_hash(v)); }
    inline const std::unordered_map<std::size_t, std::vector<IndexType>> &get_orbits() const override { return orbits; }

    inline const std::vector<IndexType>& get_orbit_from_hash(const std::size_t& hash) const override {
        return orbits.at(hash);
    }
};

} // namespace osp